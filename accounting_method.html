<!DOCTYPE html>
<html lang="fa">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>روش حسابداری — تحلیل سرشکن</title>
    <style>
      body {
        direction: rtl;
        margin: 0;
        padding: 32px;
        background: #f8fafc;
        font-family: "Segoe UI", "Tahoma", "Arial", sans-serif;
        color: #0b1220;
        line-height: 1.8;
      }
      .container {
        max-width: 1000px;
        margin: auto;
        background: #fff;
        border-radius: 12px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.05);
        padding: 36px;
      }
      h1,
      h2,
      h3 {
        color: #0b5c8a;
      }
      h1 {
        font-size: 24px;
        margin-bottom: 8px;
      }
      h2 {
        font-size: 19px;
        margin-top: 28px;
      }
      h3 {
        font-size: 16px;
      }
      p,
      li {
        font-size: 15px;
      }
      .panel {
        background: #eaf6ff;
        padding: 14px 18px;
        border-radius: 10px;
        margin: 10px 0;
        border-right: 4px solid #0b5c8a;
      }
      .example {
        background: #fff5fa;
        padding: 14px 18px;
        border-radius: 10px;
        margin: 10px 0;
        border-right: 4px solid #ff99bb;
      }
      .exercise {
        background: #fff4e6;
        padding: 14px 18px;
        border-radius: 10px;
        margin: 10px 0;
        border-right: 4px solid #ffa94d;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 12px 0;
      }
      th,
      td {
        border: 1px solid #e2e8f0;
        padding: 8px;
        text-align: center;
        font-size: 14px;
      }
      footer {
        margin-top: 24px;
        border-top: 1px dashed #ccc;
        padding-top: 12px;
        font-size: 13px;
        color: #555;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>روش حسابداری (Accounting Method)</h1>
      <p>
        در این ارائه، روش حسابداری در تحلیل سرشکن را بر اساس فصل تحلیل سرشکن از کتاب
        <strong>CLRS (Introduction to Algorithms, 4th Edition)</strong> مرور می‌کنیم. تمرکز روی درک شهودی مفهوم اعتبار
        (Credit) و نحوه‌ی طراحی هزینه‌ی سرشکن برای انواع عملیات است.
      </p>

      <h2>مقدمه</h2>

      <p>
        روش حسابداری یکی از سه روش استاندارد در تحلیل سرشکن است. هدف اصلی آن تخصیص یک «هزینهٔ سرشکن» (amortized cost) به
        هر نوع عملیات است به طوری که برای هر عملیات، اعتبار (credit) کافی برای پوشش هزینهٔ واقعیِ عملیات‌های پرهزینه که
        در آینده رخ می‌دهند، نگه داشته شود. در روش حسابداری با یک حساب اعتباری ذهنی کار می‌کنیم که از عملیات‌های
        ارزان‌تر مقداری اضافه دریافت و در حساب ذخیره می‌شود؛ سپس عملیات‌های گران را از این حساب پرداخت می‌کنیم.
      </p>

      <h2>۱. ایده‌ی کلی</h2>
      <p>
        در روش حسابداری، برای هر عملیات هزینه‌ای سرشکن‌شده (ĉ) تعریف می‌کنیم که ممکن است با هزینه‌ی واقعی (c) آن متفاوت
        باشد. اگر ĉ از c بیشتر باشد، مازاد آن به‌صورت <strong>اعتبار</strong> ذخیره می‌شود و در آینده برای پوشش عملیات
        پرهزینه‌تر مصرف می‌گردد. هدف این است که مجموع هزینه‌های سرشکن همیشه هزینه‌های واقعی را پوشش دهد و <strong>هیچ‌گاه اعتبار
        منفی نشود:</strong>
      </p>
      <div class="panel"><code style="font-size: 24px">Σĉᵢ ≥ Σcᵢ </code> برای هر از توالی عملیات.</div>
      <p>
        تحلیل زمانی عملیات در روش حسابداری بر پایه‌ی انتخاب درست مقادیر ĉᵢ است تا بتوانیم برای کل توالی n عمل، مجموع
        هزینه‌ی واقعی را در حد O(n) نگه داریم.
      </p>

      <h2>۲. مثال اول — پشته با PUSH، POP و MULTIPOP</h2>
      <p>فرض کنید پشته‌ای داریم با عملیات‌های زیر:</p>
      <ul>
        <li><code dir="ltr">PUSH()</code> — افزودن یک عنصر (هزینه‌ی واقعی = 1)</li>
        <li><code dir="ltr">POP()</code> — حذف یک عنصر (هزینه‌ی واقعی = 1)</li>
        <li>
          <code>MULTIPOP(S,k)</code> — حذف تا k عنصر (هزینه‌ی واقعی = min(k,|S|). که |S| اندازه پشته و k تعداد عناصر مد
          نظر برای حذف میباشد)
        </li>
      </ul>

      <div class="example">
        <h3>انتخاب هزینه‌ی سرشکن</h3>
        <p>در روش حسابداری، انتخاب می‌کنیم:</p>
        <p><code>ĉ_PUSH = 2</code> ، <code>ĉ_POP = 0</code> ، <code>ĉ_MULTIPOP = 0</code>.</p>
        <p>
          در هر <code>PUSH</code>، یک واحد برای کار واقعی خرج می‌شود و یک واحد به‌عنوان اعتبار روی عنصر ذخیره می‌گردد.
          هنگامی که عنصر با <code>POP</code> یا در <code>MULTIPOP</code> حذف می‌شود، هزینه‌ی واقعی حذف (۱) از اعتبار از
          قبل ذخیره شده‌ی همان عنصر پرداخت می‌شود.
        </p>
      </div>

      <p>
        در نتیجه، مجموع هزینه‌ی سرشکن در n عمل حداکثر برابر ۲n (اگر فقط PUSH داشته باشیم) است، و چون هزینه‌ی واقعی
        حداکثر به‌اندازه‌ی آن است، میانگین هزینه‌ی هر عمل برابر O(1) می‌شود.
      </p>

      <table>
        <tr>
          <th>عملیات</th>
          <th>هزینه واقعی</th>
          <th>هزینه سرشکن</th>
          <th>توضیح</th>
        </tr>
        <tr>
          <td>PUSH</td>
          <td>1</td>
          <td>2</td>
          <td>۱ برای کار + ۱ ذخیره روی عنصر</td>
        </tr>
        <tr>
          <td>POP</td>
          <td>1</td>
          <td>0</td>
          <td>هزینه از اعتبار عنصر پرداخت می‌شود</td>
        </tr>
        <tr>
          <td>MULTIPOP(k)</td>
          <td>≤k</td>
          <td>0</td>
          <td>هر حذف از اعتبار خود عنصر پرداخت می‌شود</td>
        </tr>
      </table>

      <h2>۳. مثال دوم — شمارنده دودویی (Binary Counter)</h2>
      <p>
        شمارنده‌ای دودویی با b بیت داریم که از صفر شروع می‌کند. هر بار عمل <code dir="ltr">INCREMENT()</code> یک واحد به
        مقدار آن اضافه می‌کند. هزینه‌ی واقعی هر INCREMENT برابر با تعداد بیت‌هایی است که از 1 به 0 یا از 0 به 1 تغییر
        می‌کنند.
      </p>

      <div class="example">
        <h3>انتخاب هزینه‌ی سرشکن</h3>
        <p>
          در هر INCREMENT دو واحد اعتبار در نظر می‌گیریم: <code>ĉ = 2</code>. هرگاه بیتی از 0 به 1 تغییر کند، یک واحد
          صرف هزینه‌ی خود عمل، و یک واحد اعتبار روی آن ذخیره می‌شود تا در آینده هنگام بازگشت از 1 به 0 هزینه‌اش از آن
          اعتبار پرداخت گردد.
        </p>
      </div>

      <p>
        وقتی در یک عمل INCREMENT، تعداد k بیت از 1 به 0 تغییر کنند و یک بیت از 0 به 1، هزینه‌ی واقعی برابر k+1 است؛ ولی
        این k بیت قبلاً اعتبار داشته‌اند، پس هزینه‌شان پرداخت شده و فقط ۲ واحد برای بیت جدید لازم است. بنابراین هزینه‌ی
        سرشکن ثابت است و مجموع هزینه‌ها برای n عمل، چون مجموع تعدادی عمل با مرتبه زمانی ثابت (2) است، حداکثر برابر 2n
        میشود که از مرتبه زمانی <strong>O(n)</strong> است.
      </p>

      <h2>۴. مثال سوم — جدول پویا (Dynamic Table)</h2>
      <p>
        در جدول پویا (مثل آرایه‌ی پویا)، هنگام پر شدن ظرفیت، اندازه را دو برابر می‌کنیم. در چنین حالتی، همه‌ی عناصر باید
        کپی شوند که پرهزینه است.
      </p>
      <p>
        برای متعادل‌سازی هزینه‌ها، در هر INSERT هزینه‌ی سرشکن <code>ĉ = 2</code> می‌پردازیم: یک واحد برای درج واقعی و یک
        واحد به‌عنوان اعتبار ذخیره می‌شود. هنگامی که ظرفیت دو برابر می‌شود، اعتبار ذخیره‌شده‌ی عناصر قبلی هزینه‌ی کپی را
        پوشش می‌دهد. بنابراین میانگین هزینه برای هر INSERT نیز O(1) است که در مجموع برای n عمل، از مرتبه زمانی
        <strong>O(n)</strong> میشود.
      </p>

      <h2>۵. تمرین‌ها و پاسخ‌ها</h2>

      <div class="exercise">
        <h3>تمرین <span dir="ltr">16.2‑1</span></h3>
        <p>
          دنباله‌ای از عملیات‌های PUSH و POP روی یک پشته انجام می‌دهیم. اندازه‌ی پشته برابر k است و هیچوقت از آن بزرگتر
          نمیشود. بعد از هر k عملیات (یعنی چه PUSH و چه POP)، کل پشته به‌صورت خودکار کپی (backup) می‌شود.
        </p>
        <p>در این مثال، هزینه های واقعی بدین صورت است:
          <ul>
            <li>c_PUSH = 1</li>
            <li>c_POP = 1</li>
            <li>c_backup <= k </li>
          </ul>
        </p>

        <p>هزینه های سرکشن را به این شکل در نظر میگیریم:
          <ul>
            <li>ĉ_PUSH = 3 که یک واحد برای خودش استفاده میشود، دو واحد نیز برای کپی های احتمالی آینده ذخیره خواهد شد.</li>
            <li>ĉ_POP = 1</li>
            <li>ĉ_backup = 0 </li>
          </ul>
        </p>

        <p>
          مانند مثال های قبل، در این مثال نیز میتوانیم مطمئن باشیم که همواره مجموع هزینه سرشکن، بزرگتر یا مساوی هزینه واقعی است. زیرا با هر عمل PUSH دو واحد اعتبار ذخیره میکنیم که حتی اگر یک عنصر بیش از یک بار هم کپی شود، اعتبار ذخیره شده منفی نشود و همواره مثبت بماند.
        </p>
      </div>
      

      <h2>۶. چند نکته و جمع‌بندی</h2>
      <ul>
        <li>در روش حسابداری، هر عملیات بخشی از هزینه‌ی عملیات‌های آینده را پیشاپیش پرداخت می‌کند.</li>
        <li>اعتبارها باید طوری طراحی شوند که هیچ‌گاه منفی نشوند.</li>
        <li>معمولاً برای عملیات‌هایی که «آیتمی» کار می‌کنند (مثل PUSH) هزینهٔ سرشکن را به‌صورت «ثابت» در نظر می‌گیریم و این اعتبار را به عنصر وصل می‌کنیم.</li>
        <li>برای رویدادهایی که هزینه‌شان به اندازهٔ تعداد عناصر فعلی بستگی دارد (مثل کپی کردن عناصر آرایه)، اعتبار را هنگام وارد کردن عناصر انباشته کنید تا هنگام کپی از آن‌ها استفاده شود.</li>
        <li>یک قاعدهٔ سرانگشتی: اگر هزینهٔ واقعیِ گران تنها هنگامی رخ می‌دهد که تعداد عناصر دو برابر شده یا مشابه آن باشد، اختصاص 2 یا 3 واحد اعتبار به ازای هر عنصر اغلب کافی است.</li>
      </ul>
    
    </div>
  </body>
</html>
